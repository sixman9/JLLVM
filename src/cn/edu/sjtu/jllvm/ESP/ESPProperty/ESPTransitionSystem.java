package cn.edu.sjtu.jllvm.ESP.ESPProperty;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Set;

import stp.Expr;
import cn.edu.sjtu.jllvm.ESP.CFGUtils;
import cn.edu.sjtu.jllvm.ESP.ILocation;
import cn.edu.sjtu.jllvm.ESP.IState;
import cn.edu.sjtu.jllvm.ESP.ITransitionSystem;
import cn.edu.sjtu.jllvm.ESP.IWorklist;
import cn.edu.sjtu.jllvm.ESP.SolverUtil;
import cn.edu.sjtu.jllvm.ESP.Worklist;
import cn.edu.sjtu.jllvm.VMCore.BasicBlock;
import cn.edu.sjtu.jllvm.VMCore.Module;
import cn.edu.sjtu.jllvm.VMCore.Constants.Function;
import cn.edu.sjtu.jllvm.VMCore.Instructions.Instruction;
import cn.edu.sjtu.jllvm.test.ESPArguments;

/**
 * @author liuhao 2011-12-19
 * A system contain a CFG
 */
public class ESPTransitionSystem implements ITransitionSystem {
	private Hashtable<ILocation, IState> reach;
	
	private Module prog;
	
	private List<ILocation> entryList;
	private Worklist worklist;
	
	//control multi stateId(multi mutex situation)
	private ILocation lastEntry;
	public static String currentStateId = "";
	private List<String> toVisitedStateIds;
	
	//store lock information generated by esp analysis
	private String lockStateInfo = "";
	
	public static boolean USE_SOLVER = false;
	
	public static final int NOT_EXECUTIONSTATE = 0;
	public static final int ALL_INFO = 1;
	
	public static int DEBUG_INFO = ALL_INFO;
	
	public static int switch_label = 1;
	
	//Run all functions 
	public ESPTransitionSystem(Module prog){
		this.prog = prog;
		
		reach = new Hashtable<ILocation, IState>();
	
		entryList = new ArrayList<ILocation>();
		for(Function f: prog.getFunctions()){
			entryList.add(f.getEntry().getFirst());
		}
		
		toVisitedStateIds = new ArrayList<String>();
	}
	
	//Only run the special input functions 
	public ESPTransitionSystem(Module prog, String[] functionNames){
		this.prog = prog;
		
		reach = new Hashtable<ILocation, IState>();
	
		entryList = new ArrayList<ILocation>();
		for(String fn: functionNames){
			Function f = prog.getFunction(fn);
			if(f == null)
				continue;
			
			entryList.add(f.getEntry().getFirst());
		}
		
		toVisitedStateIds = new ArrayList<String>();
	}
	
	@Override
	public void setWorklist(IWorklist worklist) {
		this.worklist = (Worklist)worklist;
	}

	@Override
	public void setAllLocationStateBottom() {
		for(Function f: prog.getFunctions()){
			for(BasicBlock bb: f.getBasicBlocks()){
				for(Instruction inst: bb.getInstructions()){
					reach.put(inst, ESPStateFactory.createBottomState());
				}
			}
		}
	}

	@Override
	public Hashtable<ILocation, IState> getAllLocationStates() {
		return reach;
	}

	@Override
	public boolean hasEntry() {
		return entryList.size()!=0;
	}

	@Override
	public ILocation nextEntry() {
		if(toVisitedStateIds.size()!=0){
			ESPTransitionSystem.currentStateId = toVisitedStateIds.remove(0);
			
			return lastEntry;
		}
		
		if(!hasEntry())
			return null;
		
		ILocation entry = entryList.remove(0);
		Function toVisitedFunction = ((Instruction)entry).getFunction();
		toVisitedStateIds = parseFunctionForStateIds(toVisitedFunction);
		
		if(toVisitedStateIds.size()==0){
			return nextEntry();
		}else{
			ESPTransitionSystem.currentStateId = toVisitedStateIds.remove(0);
		}
			
		if(ESPArguments.DEBUG_CURRENT_FUNCTION){
			System.out.println("Solving "+toVisitedFunction.getFunctionName()+" ...");
		}
		
		lastEntry = entry;
		
		lockStateInfo+="#"+((Instruction)lastEntry).getFunction().getFunctionName()+":\n";
		return entry;
	}

	/* (non-Javadoc)
	 * @see cn.edu.sjtu.jllvm.ModelChecking.ITransitionSystem#getSuccessors(cn.edu.sjtu.jllvm.ModelChecking.ILocation)
	 */
	@Override
	public List<ILocation> getSuccessors(ILocation loc) {
		List<ILocation> succs = new ArrayList<ILocation>();
		
		Instruction inst = (Instruction)loc;
		Instruction next = inst.getNextInst();
		if(next!=null){	//inst is not TerminatorInstruction
			succs.add(next);
		}else{		//inst is the terminator of this basic block
			List<BasicBlock> bbs = inst.getParent().getSuccessors();
			
			for(BasicBlock bb:bbs){
				succs.add(bb.getFirst());
			}
		}
		
		return succs;
	}
	
	/**
	 * Separately handling Branch, Merge, Call and other edges
	 */
	@Override
	public IState getPost(ILocation src, ILocation dest) {
		Instruction src_inst = (Instruction)src;
		Instruction dest_inst = (Instruction)dest;
		
		ESPState src_state = (ESPState)reach.get(src_inst);
		ESPState post_state = (ESPState)src_state.copy();		//changed state
		
		if(src_inst.isMerge()){
			if(adjustWorklist()){
				post_state = ESPStateFactory.createBottomState();
				
				return null;
			}
		}
		
		if(src_inst.isConditionalBranch()){	//a branch			
			if(USE_SOLVER){
				List<Expr> exprList = CFGUtils.parseSTPExprs(src_inst);
				
				
				String blockId = dest_inst.getParent().getBlockID();
				if(src_inst.getOperand(1).toString().equals(blockId)){	// true branch
					Expr stp_expr = null;
					
					if(exprList.size()>=2){
						Expr [] exprArray = new Expr[exprList.size()];
						exprList.toArray(exprArray);
						stp_expr = SolverUtil.vc.andExprN(exprArray);
					}else if (exprList.size()==1) {
						stp_expr = exprList.get(0);
					}else{
						System.out.println("Empty expr list: "+src_inst.toString());
					}
					
					post_state.addConstraint(stp_expr);
				}else{	// false branch
					Expr stp_expr = null;
					
					if(exprList.size()>=2){
						Expr [] exprArray = new Expr[exprList.size()];
						exprList.toArray(exprArray);
						stp_expr = SolverUtil.vc.andExprN(exprArray);
					}else if (exprList.size()==1) {
						stp_expr = exprList.get(0);
					}else{
						System.out.println("Empty expr list: "+src_inst.toString());
					}
					
					post_state.addConstraint(SolverUtil.vc.notExpr(stp_expr));
				}
			}else{
				String constraint = CFGUtils.parseVariableString(src_inst, 0);
				
				String blockId = dest_inst.getParent().getBlockID();
				if(src_inst.getOperand(1).toString().equals(blockId)){	// true branch
					post_state.addConstraint(constraint); 
					
				}else{	// false branch
					post_state.addConstraint("!"+constraint);
				}
			}
		}else if(src_inst.isSwitch()){
			if(USE_SOLVER){
				List<Expr> exprList = CFGUtils.parseSTPExprs(src_inst);
				Expr stp_expr = null;
				
				if(exprList.size()>=2){
					Expr [] exprArray = new Expr[exprList.size()];
					exprList.toArray(exprArray);
					stp_expr = SolverUtil.vc.andExprN(exprArray);
				}else if (exprList.size()==1) {
					stp_expr = exprList.get(0);
				}else{
					//System.out.println("Empty expr list:"+src_inst.toString());
				}
				
				int numOperand = src_inst.getNumOperands();
				String blockId = dest_inst.getParent().getBlockID();
				if(!blockId.equals(src_inst.getOperand(switch_label).toString())){
					
					switch_label = 1;
					if(!blockId.equals(src_inst.getOperand(switch_label).toString())){
						System.out.println("SWITCH_LABEL ERROR!");
					}
				}
				
				if(switch_label==1){
					Expr swi = CFGUtils.getOperandExpr(src_inst, 0);
					for(int j=2; j<numOperand; j+=2){
						Expr tar = CFGUtils.getOperandExpr(src_inst, j);
						if(stp_expr!=null){
							stp_expr = SolverUtil.vc.andExpr(stp_expr, SolverUtil.vc.notExpr(SolverUtil.vc.eqExpr(swi, tar)));
						}else{
							stp_expr = SolverUtil.vc.notExpr(SolverUtil.vc.eqExpr(swi, tar));
						}
						
					}
					post_state.addConstraint(stp_expr);
					
				}else{
					Expr tar = CFGUtils.getOperandExpr(src_inst, switch_label-1);
					Expr swi = CFGUtils.getOperandExpr(src_inst, 0);
					if(stp_expr!=null){
						stp_expr = SolverUtil.vc.andExpr(stp_expr, SolverUtil.vc.eqExpr(swi, tar));
					}else{
						stp_expr = SolverUtil.vc.eqExpr(swi, tar);
					}
					
					post_state.addConstraint(stp_expr);
				}
				
				switch_label+=2;
				if(switch_label>=numOperand){
					switch_label=1;
				}
			}else{
				int numOperand = src_inst.getNumOperands();
				String constraint_id = CFGUtils.parseVariableString(src_inst, 0);
				
				String blockId = dest_inst.getParent().getBlockID();
				for(int i = 2; i<numOperand; i+=2){
					if(src_inst.getOperand(i).toString().equals(blockId)){
						post_state.addConstraint(constraint_id+"=="+src_inst.getOperand(i+1).toString());
					}
				}
				
				if(!blockId.equals(src_inst.getOperand(switch_label).toString())){
					//System.out.println("SWITCH_LABEL ERROR!");
					switch_label = 1;
					if(!blockId.equals(src_inst.getOperand(switch_label).toString())){
						System.out.println("SWITCH_LABEL ERROR!");
					}
				}
				
				if(switch_label==1){
					String constraint="";
					String swi = src_inst.getOperand(0).toString();
					for(int j=2; j<numOperand; j+=2){
						constraint+=swi+"!="+src_inst.getOperand(j).toString()+"&";
					}
					constraint= constraint.substring(0, constraint.length()-2);
					post_state.addConstraint(constraint);
					
				}else{
					String constraint="";
					String swi = src_inst.getOperand(0).toString();
					constraint=swi+"=="+src_inst.getOperand(switch_label-1).toString();
				}
				
				switch_label+=2;
				if(switch_label>=numOperand){
					switch_label=1;
				}
				
			}
		}
		
		if(src_inst.isCall()){
			String fName = src_inst.getOperand(0).toString();
			if(isRelatedFunction(fName)){
				String mutex = CFGUtils.parseVariableString(src_inst, 1);
				String curId = ESPTransitionSystem.currentStateId;
				
				if(curId.equals(mutex)){
					lockStateInfo += src_state.getStateString(mutex);
					lockStateInfo += "  ";
					if(fName.endsWith("unlock")){
						lockStateInfo += "UNLOCK ";
					}else{
						lockStateInfo += "LOCK ";
					}
					lockStateInfo += mutex+"  <- "+src_inst.toString() +"\n";
					
					src_state.transit(fName);	// change state
					
					lockStateInfo += src_state.getStateString(mutex)+"\n";
					
					post_state = (ESPState)src_state.copy();
				}
			}else{		//interprocedural
				
			}
		}
		
		return post_state;
	}
	
	/** 
	 * adjust worklist ,make all merge nodes in the tail of the worklist.
	 * If the worklist isn't changed, it means that there are only mearge nodes in the worklist
	 * else the worklist has node that is not merge node and make it be the first of the list.
	 * @return true if worklist is changed, false if worklist isn't changed
	 */
	public boolean adjustWorklist(){
		List<Instruction> nodes = worklist.getNodes();
		List<IState> states = worklist.getStates();
		boolean tag = false;
		for(int i=0; i<nodes.size(); i++){
			Instruction inst = nodes.get(i);
			if(!inst.isMerge()){
				nodes.remove(i);
				
				IState state = states.remove(i);
				nodes.add(0, inst);
				states.add(0, state);
				
				tag = true;
			}
		}
		
		return tag;
	}
	
	public boolean isRelatedFunction(String functionName){
		if(functionName.equals("pthread_mutex_unlock") || functionName.equals("pthread_mutex_lock"))
			return true;
		
		return false;
	}
	
	public List<String> parseFunctionForStateIds(Function f){
		Set<String> set = new HashSet<String>();
		for(BasicBlock b: f.getBasicBlocks()){
			for(Instruction i: b.getInstructions()){
				if(i.isCall() && isRelatedFunction(i.getOperand(0).toString())){
					String mutex = CFGUtils.parseVariableString(i, 1);
					set.add(mutex);
				}
			}
		}
		
		return new ArrayList<String>(set);
	}
	
	/**
	 * print debug info
	 */
	@Override
	public void print(){
		
		if(ESPArguments.DEBUG_ALL_INFO){
			for(Function f: prog.getFunctions()){
				for(BasicBlock bb: f.getBasicBlocks()){
					for(Instruction inst: bb.getInstructions()){
						IState istate = reach.get(inst);
						
						if(ESPArguments.DEBUG_INFO_TO_FILE){
							ESPArguments.fileWriter.println(inst.toString()+"\n"+istate.toString());
						}else{
							System.out.println(inst.toString()+"\n"+istate.toString());
						}
					}
				}
			}
		}
		
		if(ESPArguments.DEBUG_LOCK_INFO){
			String lockInfos[] = lockStateInfo.split("#");
			
			for(String info: lockInfos){
				if(info.length()>40){
					if(ESPArguments.DEBUG_INFO_TO_FILE){
						ESPArguments.fileWriter.println("# "+info);
					}else{
						System.out.println(info+"\n");
					}
				}
			}
		}
	}
	
	@Override
	public String getInfo(){
		return lockStateInfo;
	}
}
